{"searchDocs":[{"title":"API surface for objects","type":0,"sectionRef":"#","url":"/blog/api-surface","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#properties","content":" Properties are the state of an object. They can be read and written and notify users about changes. Properties can be of any type.  interface HeatingSystem { temperature: float }   In the example above the temperature property is of type float. The type can be any type that is supported by the IDL. The type can be a primitive type or a complex type. A primitive type can be one of the following:  int : integer valuefloat : floating point valuestring : string valuebool : boolean value  Types can also be arrays. To define arrays of a type just append the [] to the type (for example int[]).  ","version":null,"tagName":"h2"},{"title":"Operations​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#operations","content":" Operations are functions that can be called on an object. They can be synchronous or asynchronous. Operations can receive parameters and return a value.  interface HeatingSystem { setTemperature(float temperature) }   In the example above the setTemperature operation receives a parameter of type float. The operation does not return a value.  ","version":null,"tagName":"h2"},{"title":"Signals​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#signals","content":" Signals are events that can be emitted by an object. They can be received by users of the object.  interface HeatingSystem { signal maxTemperatureReached() }   In the example above the maxTemperatureReached signal does not receive any parameters.  ","version":null,"tagName":"h2"},{"title":"Structures​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#structures","content":" Different than objects which can be interacted with, structures are just data structures that can be used to send complex information between objects. A structure is defined as follows:  struct Struct1 {}   A struct can have fields of any type.  ","version":null,"tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#enumerations","content":" An enumeration is a set of named values. An enumeration is defined as follows:  enum Enum1 { value1 value2 }   An enumeration can be used as a type for properties, operations and signals.  ","version":null,"tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#modules","content":" A module is a collection of objects, structures and enumerations. A module is defined as follows:  module name version interface Name {}   The version of a module is a string that follows the semver format. The version of a module is optional. If no version is specified the version is 0.0.0.  Working with the API surface  When designing an API surface it is important to keep the following in mind: ","version":null,"tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/maker/intro","content":"","keywords":"","version":"Next"},{"title":"Maker​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#maker","content":" A user which creates templates is called a maker. Normally is is possible to contribute to existing templates to enhance in an open discussion the quality for everyone. But often there is also a desire to solve a new problem or to create a project specific adaptation. In these cases it makes sense to fork a template or to create a new template.  templates allows you to solve all kind of API structured problems in a very easy way.  ","version":"Next","tagName":"h2"},{"title":"Creating a template​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#creating-a-template","content":" A template is a folder with a common structure consisting of a rules document, which controls the code generation process and the templates folder. The templates will be listed inside a rules document. Later a solution document will link the template with API modules for code generation.  Below is roughly the process to create and develop a template  Create a template folder with rules document and templates folderCreate an ApiGear Studio API project with a demo APIAdd a solution to the API project to link API modules with the templateEdit the template and re-generate the output  The templates are written using the go-template template language and each template should end with .tpl. ApiGear extends the template language by custom programming language specific filters to ease many complex tasks.  The Go-Template is used in several projects and is well documented. The ApiGear extensions are documented in the Filters section.  ","version":"Next","tagName":"h2"},{"title":"Your first template​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#your-first-template","content":" A typical template folder structure looks like this  first/ rules.yaml templates/welcome.txt.tpl   The rules document is a YAML document and lists all template file and how they shall be written inside the output folder. A simple rules document could look like this:  features: - name: default scopes: - match: system documents: - source: welcome.txt.tpl target: welcome.txt   The first level (here default) defines a feature. This can be enabled or disabled using the feature settings for the code generator. The next level (here system) defines to which symbol is shall be applied. A symbol is a defined location inside the API description.  Inside an API there exists the following symbols:  system: will be applied once for the root level systemmodule: will be applied for each module in the systeminterface: will be is applied for each interface inside the modulestruct: will be is applied for each struct inside the moduleenum: will be is applied for each enum inside the module  For each of these symbols inside the API description the target documents are written based on the source template.  You could think of the underlying logic of a rules document like this (using a python pseudo-code):  system = ... write_system_documents() for module in system.modules: write_module_documents() for interface in module.interfaces: write_interface_documents() for struct in module.structs: write_struct_documents() for enum in module.enums: write_enum_documents()   Here is a more elaborate example of a rules document:  # rules.yaml features: - name: default scopes: - match: system documents: - source: system.md.tpl target: system.md - match: module documents: - source: module.md.tpl target: {{.Module.Name}}.md - match: interface: documents: - source: interface.md.tpl target: {{.Interface.Name}}.md - match: struct documents: - source: struct.md.tpl target: {{.Struct.Name}}.md - match: enum documents: - source: enum.md.tpl target: {{.Enum.Name}}.md - name: summary scopes: - match: system documents: - source: summary.md.tpl target: summary.md   The {{ }} are a template expression. For example {{.Module.Name}} will be replaced with the content of module name. This allows you to write exactly these document names you require.  Additional to the template tags, the template engine also support filters. A filter is a function which takes a object and return a string. For example {{ lower .Module.Name }} or {{ .Module.Name | lower }} will lower case the module name. There are more filters in the in our filters documentation. ","version":"Next","tagName":"h2"},{"title":"Rules Document","type":0,"sectionRef":"#","url":"/docs/advanced/maker/rules","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#features","content":" Features are an isolated part of the code generator. When running the code generator features can be enabled and disable.  A feature is declared by name inside the features root tag.  features: - name: feature1 - name: feature2   A feature can contain a prefix target path as also a scope for documents.  features: - name: feature1 prefix: {{module.name}}/   Typical features are api, scaffold but also protocols like http, wamp.  A feature can have these properties:  needs: defines feature flag which other features need to be enabledprefix: defines a prefix output pathscope: defines a scope for documents with a match expression (e.g. system, module, interface, struct, enum)  ","version":"Next","tagName":"h2"},{"title":"Feature dependencies​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#feature-dependencies","content":" Needs allows to define a dependency between features. For example the scaffold feature needs the api feature to be enabled.  features: - name: api - name: scaffold needs: - api   ","version":"Next","tagName":"h3"},{"title":"Scopes​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#scopes","content":" A scope defined the context for the template for language for the defined documents. The context defines the available objects available inside the template language. For example a module scope will always have defined features, system and module in the template document.  features: - name: feature1 scopes: - match: system documents: - { source: system.go, target: system.go } - match: module documents: - { source: module.go, target: module.go } - match: interface documents: - { source: interface.go, target: interface.go } - match: struct documents: - { source: struct.go, target: struct.go } - match: enum documents: - { source: enum.go, target: enum.go }   A scope with the match interface iterates over all interfaces in all modules and has defined a context with features, system and module and the current interface in it.  ","version":"Next","tagName":"h2"},{"title":"Match logic​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#match-logic","content":" match: system called once for the systemcontext =&gt; { features, system } match: module called for each modulecontext =&gt; { features, system, module } match: interface called once per interface in all modulescontext =&gt; { features, system, module, interface } match: struct called once per struct in all modulescontext =&gt; { features, system, module, struct } match: enum called once per enum in all modulescontext =&gt; { features, system, module, enum }  ","version":"Next","tagName":"h3"},{"title":"Documents​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#documents","content":" A document defines the source template and the target where to write the document.  The document define the source, target and some additional flags for writing.  source: source path inside the templates directory.target: target template string inside the output directory.force: if true, the document will be forced to be overwritten when re-generated.raw: if true, document will be just copied and not treated as template. Raw if off by default. ","version":"Next","tagName":"h2"},{"title":"Symbol Reference","type":0,"sectionRef":"#","url":"/docs/advanced/maker/symbols","content":"","keywords":"","version":"Next"},{"title":"Named Element​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#named-element","content":" Named element is the base element for all symbols. It contains the following properties:  Name: string name of the element Description: string test to describe the element Meta: object free form data, evaluated by the technology template Kind: string one of [module, interface, struct, enum, property, operation, signal]  ","version":"Next","tagName":"h2"},{"title":"Typed Element​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#typed-element","content":" Typed element is a named element with additional properties for typing  Type type information one of [bool, int, float, string] or reference to interface, struct, enum Array: true if the type is an arrayIsPrimitive: primitive type type is one of [bool, int, float, string] IsSymbol: is reference to type type is one of struct, enum, interface IsPrimitiveArray: array with items of primitive typeIsSymbolArray: array with item of reference to typeIsArray: true if the type is an array  ","version":"Next","tagName":"h2"},{"title":"Module​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#module","content":" The module is an element with additional version and an information object. Additional it contains a list of interfaces, structures and enumerations  All information from the element plus  Version: stringInfo: information objectInterfaces: array of interface elementsStructs: array of struct elementsEnums: array of enum elements  ","version":"Next","tagName":"h2"},{"title":"Information​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#information","content":" The information object allows customers to provide additional information about the API.  Title: stringDescription: stringTermsOfService: stringContact: is an object consisting of name, url and emailLicense: is an object containing of name and url  ","version":"Next","tagName":"h3"},{"title":"Interface​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#interface","content":" The interface is an container element for properties, operations and signals.  All information from the element plus  Properties: array of property elementsOperations: array of operation elementsSignals: array of signal elements  ","version":"Next","tagName":"h2"},{"title":"Property​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#property","content":" Property is a typed element.  All information from the typed element.  ","version":"Next","tagName":"h3"},{"title":"Operation​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#operation","content":" Operation is a named element with an additional list of typed parameters. The return element defines the return type.  All information from the typed element plus  Params: array of typed elementsReturn: type information  ","version":"Next","tagName":"h3"},{"title":"Signal​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#signal","content":" Signal is a typed element and has the same signature as operation, besides the return type information is ignored.  All information from the typed element plus  Params: array of typed elements  ","version":"Next","tagName":"h3"},{"title":"Structure​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#structure","content":" Structure is an element and act as a container for fields.  All information from the element, plus  Fields: array of typed elements  ","version":"Next","tagName":"h2"},{"title":"Field​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#field","content":" Field is a typed element.  All information from the typed element  ","version":"Next","tagName":"h3"},{"title":"Enumeration​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#enumeration","content":" Enumeration is an element and act as a container for members.  All information from the element, plus  Members: array of member  ","version":"Next","tagName":"h2"},{"title":"Member​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#member","content":" Member is a element with an additional value.  All information from the named element, plus  Value: the value of the member ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/monitor/intro","content":"","keywords":"","version":"Next"},{"title":"What is API Monitoring?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#what-is-api-monitoring","content":" API Monitoring is a feature that allows you to monitor the usage of your API. It allows you to detect anomalies and to see how your API is used during runtime. This is especially useful during development and testing.  ","version":"Next","tagName":"h2"},{"title":"How does it work?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-does-it-work","content":" API Monitoring is a protocol that is implemented by the ApiGear templates. It allows clients to send API usage information to an API Monitoring Service. For development a server is embedded into your local ApiGear Studio / CLI application. This allows developers to see in real-time how the API is used and detect any anomalies fast.  ","version":"Next","tagName":"h2"},{"title":"How to use it?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-to-use-it","content":" To use API Monitoring you need to use a template that supports it. Please check the documentation of the template you are using for more information.  When you generate your API SDK you can use the monitor feature to include the monitoring code into your API SDK. This will allow you to send API usage information to the monitoring server.  When your client application is running messages will be send to the monitoring server. You can then use the monitoring server to see the API usage information.  ","version":"Next","tagName":"h2"},{"title":"How to setup the monitoring server?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-to-setup-the-monitoring-server","content":" The monitoring server is embedded into the ApiGear Studio / CLI application. You can find the monitoring server settings in the settings page of the ApiGear Studio.  note If your template supports tracing, please consult the individual template documentation._ ","version":"Next","tagName":"h2"},{"title":"Filter Reference","type":0,"sectionRef":"#","url":"/docs/advanced/maker/filters","content":"","keywords":"","version":"Next"},{"title":"Template Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#template-filters","content":" String filters are used inside templates to transform text in different formats.  A typical usage would use the filter name followed by a string reference to the value to be transformed. For example:  {{ snake .Module.Name }}   Where . is the current context and .Module is the module object from the current context and .Name is the name property of the module object. The context can change for example inside a range loop.  {{ range .Module.Interfaces }} {{ snake .Name }} {{ end }}   Where the current context if the interface object inside the range loop.  ","version":"Next","tagName":"h2"},{"title":"String Filter​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#string-filter","content":" The list of the common string filters are listed here  ","version":"Next","tagName":"h2"},{"title":"snake, Snake, SNAKE​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#snake-snake-snake","content":" Converts a string to snake case - (lower, title, upper) case with underscores   {{snake &quot;org.demo&quot;}} =&gt; org_demo {{Snake &quot;org.demo&quot;}} =&gt; Org_Demo {{SNAKE &quot;org.demo&quot;}} =&gt; ORG_DEMO   ","version":"Next","tagName":"h3"},{"title":"camel, Camel, CAMEL​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#camel-camel-camel","content":" Converts a string to camel case - (lower, title, upper) case with first letter lower case  {{camel &quot;org.demo&quot;}} =&gt; orgDemo {{Camel &quot;org.demo&quot;}} =&gt; OrgDemo {{CAMEL &quot;org.demo&quot;}} =&gt; ORGDEMO   ","version":"Next","tagName":"h3"},{"title":"dot, Dot, DOT​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#dot-dot-dot","content":" Converts a string to dot case - (lower, title, upper) case with dots  {{dot &quot;org.demo&quot;}} =&gt; org.demo {{Dot &quot;org.demo&quot;}} =&gt; Org.Demo {{DOT &quot;org.demo&quot;}} =&gt; ORG.DEMO   ","version":"Next","tagName":"h3"},{"title":"kebap, Kebap, KEBAP​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#kebap-kebap-kebap","content":" Converts a string to kebap case - (lower, title, upper) case with dashes  {{kebap &quot;org.demo&quot;}} =&gt; org-demo {{Kebap &quot;org.demo&quot;}} =&gt; Org-Demo {{KEBAP &quot;org.demo&quot;}} =&gt; ORG-DEMO   ","version":"Next","tagName":"h3"},{"title":"path, Path, PATH​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#path-path-path","content":" Converts a string to path case - (lower, title, upper) case with slashes  {{path &quot;org.demo&quot;}} =&gt; org/demo {{Path &quot;org.demo&quot;}} =&gt; Org/Demo {{PATH &quot;org.demo&quot;}} =&gt; ORG/DEMO   ","version":"Next","tagName":"h3"},{"title":"lower​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#lower","content":" Converts a string to lower case  {{lower &quot;org.demo&quot;}} =&gt; org.demo   ","version":"Next","tagName":"h3"},{"title":"upper*​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#upper","content":" Converts a string to upper case  {{upper &quot;org.demo&quot;}} =&gt; ORG.DEMO   ","version":"Next","tagName":"h3"},{"title":"upperFirst​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#upperfirst","content":" Converts the first letter of a string to upper case  {{upper1 &quot;org.demo&quot;}} =&gt; Org.demo   ","version":"Next","tagName":"h3"},{"title":"lowerFirst​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#lowerfirst","content":" Converts the first letter of a string to lower case  {{lower1 &quot;org.demo&quot;}} =&gt; org.demo   ","version":"Next","tagName":"h3"},{"title":"first, First, FIRST​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#first-first-first","content":" Returns the first character of a string as lower, unchanged, upper case  {{first &quot;org.demo&quot;}} =&gt; o {{First &quot;org.demo&quot;}} =&gt; o {{FIRST &quot;org.demo&quot;}} =&gt; O   ","version":"Next","tagName":"h3"},{"title":"join​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#join","content":" joins a list of strings with a separator  {{join .Module.Interfaces &quot;, &quot;}} =&gt; org.demo.Interface1, org.demo.Interface2   ","version":"Next","tagName":"h3"},{"title":"trimPrefix​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#trimprefix","content":" Trims a prefix from a string  {{trimPrefix &quot;org.demo&quot; &quot;org.&quot;}} =&gt; demo   ","version":"Next","tagName":"h3"},{"title":"trimSuffix​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#trimsuffix","content":" Trims a suffix from a string  {{trimSuffix &quot;org.demo&quot; &quot;.demo&quot;}} =&gt; org   ","version":"Next","tagName":"h3"},{"title":"replace​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#replace","content":" Replaces a string with another string  {{replace &quot;org.demo&quot; &quot;org&quot; &quot;com&quot;}} =&gt; com.demo   ","version":"Next","tagName":"h3"},{"title":"int2word, Int2Word, INT2WORD​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#int2word-int2word-int2word","content":" Converts an integer to words (lower, title and upper case)  {{int2word 1}} =&gt; one {{Int2Word 1}} =&gt; One {{INT2WORD 1}} =&gt; ONE   ","version":"Next","tagName":"h3"},{"title":"plural​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#plural","content":" pluralizes a string  {{plural &quot;org.demo&quot;}} =&gt; org.demos   ","version":"Next","tagName":"h3"},{"title":"nl​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#nl","content":" prints a new line  {{nl}}   ","version":"Next","tagName":"h3"},{"title":"version​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#version","content":" extracts major, minor, build version from a version string  {{$v := version &quot;1.2.3&quot;}} {{$v}} =&gt; 1.2.3 {{$v.Major}} =&gt; 1 {{$v.Minor}} =&gt; 2 {{$v.Build}} =&gt; 3   ","version":"Next","tagName":"h3"},{"title":"Language Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#language-filters","content":" All programming languages share a common set of filters which then are adapted to the specifics of the language. These are return, param, params, vars, names and the default filter.  For example for the C++ programming language you would use the return and params filter named cpp14Return and cpp14Params during operation declaration.  A typical usage could look like this:  {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }}   Here the cppReturn and cppParams are the language specific filters for the C++ programming language. The &quot;&quot; is the a prefix applied to the return type and the parameters. This is used to add a namespace to the return type and the parameters. All language specific filters have the same signature.  tip We might offer a &quot;2&quot; version of a language filter in the future (e.g. cppReturn and cppReturn2) where the second version will support the prefix syntax.  These are the common filters for all languages  ","version":"Next","tagName":"h2"},{"title":"{lang}Return​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langreturn","content":" Takes and typed element and returns the type declaration of the type  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Param​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langparam","content":" Takes a typed element and returns the function parameter declaration  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}( {{ range $i, $p := .Params }} {{ if $i }}, {{ end }} {{ cppParam &quot;&quot; $p }} {{ end }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Params​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langparams","content":" Takes an operation and return the lists of function parameters  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Default​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langdefault","content":" Takes a typed element and returns default value  {{ range .Module.Interfaces }} {{ $class := .Name }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{$class}}::{{ camel .Name }}({{ cppParams &quot;&quot; .Params }}) { return {{ cppDefault &quot;&quot; .Return }}; } {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Vars​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langvars","content":" Takes a list of types and creates variable names for them  {{ cppVars &quot;&quot; .Properties }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Var​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langvar","content":" Takes a typed element and creates a variable name for it  {{ cppVar &quot;&quot; .Property }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Type​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langtype","content":" Takes a typed element and returns the type declaration of the type  {{ cppType &quot;&quot; .Property }}   ","version":"Next","tagName":"h3"},{"title":"C++14 Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#c14-filters","content":" cppReturn: takes a typed element and returns the type declaration of the typecppParam: takes a typed element and returns the function parameter declarationcppParams: takes an operation and return the lists of function parameterscppDefault: takes a typed element and returns default valuecppVars: takes a list of types and creates variable names for themcppVar: takes a typed element and creates a variable name for itcppType: takes a typed element and returns the type declaration of the typecppConstType: takes a typed element and returns the type declaration of the type with const qualifiercppNs: takes a symbol and returns the namespace declarationcppNsOpen: takes a symbol and returns the namespace openingcppNsClose: takes a symbol and returns the namespace closingcppGpl: takes a symbol and returns the GPL license header  ","version":"Next","tagName":"h2"},{"title":"Go Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#go-filters","content":" goReturn: takes a typed element and returns the type declaration of the typegoParam: takes a typed element and returns the function parameter declarationgoParams: takes an operation and return the lists of function parametersgoDefault: takes a typed element and returns default valuegoVars: takes a list of types and creates variable names for themgoVar: takes a typed element and creates a variable name for itgoType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"TypeScript Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#typescript-filters","content":" tsReturn: takes a typed element and returns the type declaration of the typetsParam: takes a typed element and returns the function parameter declarationtsParams: takes an operation and return the lists of function parameterstsDefault: takes a typed element and returns default valuetsVars: takes a list of types and creates variable names for themtsVar: takes a typed element and creates a variable name for ittsType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"QtC++ Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#qtc-filters","content":" qtReturn: takes a typed element and returns the type declaration of the typeqtParam: takes a typed element and returns the function parameter declarationqtParams: takes an operation and return the lists of function parametersqtDefault: takes a typed element and returns default valueqtVars: takes a list of types and creates variable names for themqtVar: takes a typed element and creates a variable name for itqtType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"Python Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#python-filters","content":" pyReturn: takes a typed element and returns the type declaration of the typepyParam: takes a typed element and returns the function parameter declarationpyParams: takes an operation and return the lists of function parameterspyDefault: takes a typed element and returns default valuepyVars: takes a list of types and creates variable names for thempyVar: takes a typed element and creates a variable name for itpyType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"Unreal Engine Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#unreal-engine-filters","content":" ueReturn: takes a typed element and returns the type declaration of the typeueParam: takes a typed element and returns the function parameter declarationueParams: takes an operation and return the lists of function parametersueDefault: takes a typed element and returns default valueueVars: takes a list of types and creates variable names for themueVar: takes a typed element and creates a variable name for itueType: takes a typed element and returns the type declaration of the typeueConstType: takes a typed element and returns the type declaration of the type with const qualifier ","version":"Next","tagName":"h2"},{"title":"Template Primer","type":0,"sectionRef":"#","url":"/docs/advanced/maker/template","content":"","keywords":"","version":"Next"},{"title":"Basic Syntax​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#basic-syntax","content":" The template syntax writes the text as is to the target file. Actions inside the text allow to control the output. A action is a text inside {{ and }}. The action can be a variable, a function or a control structure.  To access variables you can use the current scope .. All variables are title case. For example to access the name of the current module you can use the following template:  {{ .Module.Name }}   ","version":"Next","tagName":"h2"},{"title":"Loops​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#loops","content":" To iterate over a list you can use the range keyword. For example to iterate over all interfaces in the current module:  {{ range .Module.Interfaces }} {{ .Name }} {{ end }}   See how the current context changes inside the range loop.  A loop can also be empty and the else keyword can be used to define the empty case. For example to iterate over all interfaces in the current module:  {{ range .Module.Interfaces }} {{ .Name }} {{ else }} No interfaces found {{ end }}   To use the index and current element you can  {{ range $index, $element := .Module.Interfaces }} {{ $index }}: {{ $element.Name }} {{ end }}   Index is a zero-based iterator and element is the current element in the loop.  tip To join lists with commas you can use the loop index. {{ range $i, $e := .Module.Interfaces }} {{ if $i}},{{ end }}{{ .Name }} {{ end }} A comma will be printed when $i is not zero.  ","version":"Next","tagName":"h2"},{"title":"Assignments​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#assignments","content":" To define new variable you can assign a value to a variable. For example to assign the name of the current module to a variable:  {{ $name := .Module.Name }}   tip This allows you to define a set of variables at the beginning of the document and used them throughout. For example a class name for the current interface: {{ $class := Camel .Name }}   ","version":"Next","tagName":"h2"},{"title":"Conditionals​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#conditionals","content":" You can use an if-end or if-else-end construct to control the output. For example to only output the name of the current interface if it is not empty:  {{ if .Name }} {{ .Name }} {{ end }}   or to output a default value if the name is empty:  {{ if .Name }} {{ .Name }} {{ else }} {{ .Module.Name }} {{ end }}   ","version":"Next","tagName":"h2"},{"title":"White Space​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#white-space","content":" The template language allows to control the white space. For example to remove the white space before the output:  {{- if .Name }} {{ .Name }} {{- end }}   or to remove the white space after the output:  {{ if .Name -}} {{ .Name }} {{ end }}   ","version":"Next","tagName":"h2"},{"title":"String Formatting​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#string-formatting","content":" You can use the printf function to format strings. For example to prefix an interface name with I:  {{ printf &quot;I%s&quot; .Name }}   or to merge two strings, where each string is camel cased.  {{ printf &quot;%s%s&quot; (Camel .Interface.Name) (Camel .Name) }}   The printf syntax is described in the Go Printf Formatting.  ","version":"Next","tagName":"h2"},{"title":"Debugging Templates​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#debugging-templates","content":" Sometimes it is useful to see the current context of the template. You can use the printf function to print the current context:  {{ printf &quot;%#v&quot; . }}  ","version":"Next","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/advanced/maker/tutorial","content":"","keywords":"","version":"Next"},{"title":"Creating a template​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#creating-a-template","content":" In this project we will create a mytemplate template inside a myproject together some apis to test the template.  mkdir myproject &amp;&amp; cd myproject mkdir mytemplate &amp;&amp; cd mytemplate   First we create our toot project folder called myproject and inside out template folder called mytemplate. Insie the mytemplate folder we place a rules document (rules.yaml) and an templates folder for our template documents.  The folder structure will look like this.  myproject/ mytemplate/ rules.yaml templates/   The rules document defines which documents are written based on which API symbols, in our case we use the module scope, as we want to create one document per module. The source document is a tpl template document and the target document is a text document, where the target name can also be a template string.  # rules.yaml features: - name: default scopes: - match: module documents: - { source: module.ts.tpl, target: {{.Module.Name}}.ts }   The module.ts.tpl file inside the template/templates folder can be empty initially, we fill it up later.  Now our basic template project is ready, it's time to link it up with an ApiGear Studio API project.  myproject/ mytemplate/ rules.yaml templates/ module.ts.tpl   ","version":"Next","tagName":"h2"},{"title":"Create API Project​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#create-api-project","content":" Open ApiGear Studio and add an API project to the myproject folder. This will create an apigear folder to the project.  From within ApiGear Studio create an API module named demo which will act as our test API.  Copy our demo API into the API document.  # demo.module.yaml schema: &quot;apigear.module/1.0&quot; name: demo version: &quot;0.1&quot; interfaces: - name: Counter properties: - name: count type: int operations: - name: increment - name: decrement   The demo API now needs to be linked to the template rules document. This is done from within a solution document, which links API modules to templates.  Open ApiGear Studio and create a solution document also called demo, and the content should look like this.  # demo.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: demo version: &quot;0.1&quot; layers: - name: demo output: ../output inputs: - demo.module.yaml template: ../mytemplate features: - default   This will first parse all defined modules (demo) and apply the given template to the modules. The documents will then be written relative to the given output directory.  Your project should look like this now:  myproject/ apigear/ demo.module.yaml demo.solution.yaml template/ rules.yaml templates/ module.ts.tpl   When you now run the solution it will create an empty output/demo.ts document inside the project directory.  Now we have a basic setup ready.  myproject/ apigear/ demo.module.yaml demo.solution.yaml template/ rules.yaml templates/ module.ts.tpl output/ demo.ts   ","version":"Next","tagName":"h2"},{"title":"Demo Goal​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#demo-goal","content":" Remember we want to create an interface for each interface inside an API module. For our demo API the resulting typescript shall look like this:  // demo.ts interface Counter { count: int; increment(): void; decrement(): void; }   This defines a standalone typescript interface to be usable in your applications.  The rules document already takes care that for each API module one typescript document is created, based on the module name. Now we need to fill in the content of the typescript code.  ","version":"Next","tagName":"h2"},{"title":"Typescript Template​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#typescript-template","content":" Inside our module.ts.liquid template document each interface in the module shall be an typescript interface. This can be accomplished with the for-loop from the liquidjs template engine.  {{ range .Module.Interfaces }} interface {{ .Name }} { } {{ end }}   After updating the module.ts.tpl with the above content, we can run the solution. This will rewrite the target document with the content of the typescript template.  interface Counter {}   ","version":"Next","tagName":"h2"},{"title":"Filling in the details​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#filling-in-the-details","content":" There are still the properties and operations missing from the source code. We can add them into the template using another for loop, which iterate over the properties and operations from the interface.  {{ range .Module.Interfaces }} interface {{ .Name }} { {{ range .Properties }} {{ .Name }}: {{ tsType . }}; {{ end }} {{ range .Operations }} {{ .Name }}(): {{ tsReturn .Return }}; {{ end }} } {{ end }}   This will already add the properties and some simple operations to the source code. After running the solution we will see the update source code.  // demo.ts interface Counter { count: int; increment(): void; decrement(): void; }   So great. Are we finished? The mindful reader already figured out that the operation parameters are missing. To demonstrate this we will add steps parameters to the increment and decrement operations.  We first update our API demo module (demo.module.yaml) adding parameters to the operations like this:  operations: - name: increment params: - name: step type: int - name: decrement params: - name: step type: int   If you would run the solution again you would no see a change as we currently not handle these parameters. We need to update the template document (module.ts.liquid) first to handle the parameters using the params filter.  {{ range .Operations }} {{ .Name }}({{ params .Params }}): {{ tsReturn .Return }}; {{ end }}   Now running the solution again will update the typescript source code to the final result:  // demo.ts interface Counter { count: int; increment(step: int): void; decrement(step: int): void; }   This shows how easy it is to create an own template solution for a supported technology.  ","version":"Next","tagName":"h2"},{"title":"Packaging​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#packaging","content":" Template packages are git repositories, which can be published to a git server. The template package can be referenced from a solution document using the git scheme.  apigear template install &lt;git-url&gt;   Or if the template is registered with the registry, it can be installed using the name.  apigear template install &lt;name&gt;   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#next-steps","content":" This simple demo shows the workflow of creating technology templates using ApiGear Studio.  ApiGear support several programming languages and technologies, such as Python, C++, TypeScript, Go and others and is able to create complex solutions for almost every application.  ApiGear comes with several advanced technology templates which provides solutions for the most common problems. In case the provides solutions do not fit your needs ApiGear is designed to allow quick adoptions of the underlying technology templates. ","version":"Next","tagName":"h2"},{"title":"Monitoring Protocol","type":0,"sectionRef":"#","url":"/docs/advanced/monitor/protocol","content":"","keywords":"","version":"Next"},{"title":"HTTP Tracing​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#http-tracing","content":" The http tracing endpoint can be looked up under ApiGear Studio settings page.  All HTTP traces work in batch mode. You need to send an array of traces to the server. The oldest trace should be the first element in the array. This should normally be the order you recieve the traces from a FIFO queue.  In case no ID was transferred we generate a running ID based on the current timestamp.  ","version":"Next","tagName":"h2"},{"title":"Tracing operation calls​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#tracing-operation-calls","content":" For an method call the message looks like this:  An API call occurs when the client calls an method. The uri is the module name, joined with the interface name. A URI fragment (#) is added for the interface methods.  { &quot;type&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;${module}.${interface}/${method}&quot;, &quot;data&quot;: &quot;${params}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Tracing property changes​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#tracing-property-changes","content":" A state change can be an partial update or a full update of all interface properties. The state is always an JSON object.  { &quot;type&quot;: &quot;state&quot;, &quot;symbol&quot;: &quot;${module}.${interface}&quot;, &quot;data&quot;: &quot;${state}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Reporting a signal notification​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#reporting-a-signal-notification","content":" For an interface signal the message looks like this  { &quot;type&quot;: &quot;signal&quot;, &quot;symbol&quot;: &quot;${module}.${interface}/${signal}&quot;, &quot;data&quot;: &quot;${params}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Websocket Tracing​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#websocket-tracing","content":" Tracing over web sockets uses the JSON-RPC protocol. The protocol is mostly the same as the http protocol.  The JSON RPC method is called trace and uses the same endpoint as the simulation server for ApiGear Studio. Where in the HTTP trace protocol the source as part of the endpoint, in the websocket protocol it is part of the message.  Otherwise all parameters, especially also the type are the same.  The websocket tracing endpoint can be looked up under ApiGear Studio settings page.  { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;trace&quot;, &quot;params&quot;: { &quot;id&quot;: &quot;1000230240&quot;, &quot;source&quot;: &quot;local-device&quot;, &quot;type&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;count.Counter/increment&quot;, &quot;data&quot;: {} } }  ","version":"Next","tagName":"h2"},{"title":"Advanced Concepts","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/advanced","content":"","keywords":"","version":"Next"},{"title":"Document information​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#document-information","content":" The info section allows user to add information related to the current document.  info: license: &lt;license-identifier&gt;   ","version":"Next","tagName":"h2"},{"title":"Meta information​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#meta-information","content":" Sometimes it is required to add additional information, which is not part of the ObjectAPI specification. For this the meta tag can be used.  interfaces: - name: Tuner meta: singleton: true config: { port: 1024 }   As the information is not part of the specification the applied code generator must have an understanding of the data. For example a C++ code generator could create a singleton type from the interface declaration.  ","version":"Next","tagName":"h2"},{"title":"Compact Writing​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#compact-writing","content":" YAML allows a compact format for single line information. This allows us to shorten API definitions considerable. For example this API  structs: - name: Error fields: - name: message, type: string - name: code type: int   Can be written in a short format like this:  structs: - name: Error fields: - { name: message, type: string } - { name: code, type: int }  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/intro","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#introduction-1","content":" The ObjectAPI specification is a project used to describe and document object oriented APIs across languages and technologies.  The ObjectAPI specification defines a set of files required to describe such an API. These files can then be used to create utilities, such as documentation, integration and/or testing tools.  The ObjectAPI Specification is often used to describe the interface between software modules or inter-process communication (IPC) in distributed systems built using a object oriented programming API. The ObjectAPI recommends to split APIs into smaller modules with loose coupling.  The documents describe an API module and its interfaces and data structures.  ","version":"Next","tagName":"h2"},{"title":"Revision History​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#revision-history","content":" ","version":"Next","tagName":"h2"},{"title":"Version 0.2​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#version-02","content":" Initial ObjectAPI specificationSimplified the ObjectAPI document format  ","version":"Next","tagName":"h3"},{"title":"Definitions​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#definitions","content":" System : A system is a collection of modules, which describe a coherent set of APIs on the same layer.Module : A module describes a name spaced collection of API symbols, such as interfaces, structures, enumerations. There exists one module per file.Interface: A interface is a description of a named object with properties, operations and signals.Structure: A structure is a data type with fields describing the data structure. A structure has no operations or signals.Enumeration: An enumeration is a enumerated integer type with a set of named values. ","version":"Next","tagName":"h2"},{"title":"API Foundation","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/core","content":"","keywords":"","version":"Next"},{"title":"Format​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#format","content":" ObjectAPI is described as an open specification format using JSON Schema. Every ObjectAPI document must conform to this JSON schema definition.  tip While the the API is described in JSON, other formats like YAML can be used as input formats and are automatically converted to JSON by the ObjectAPI tooling.  Unless otherwise noted all file names in this specification are case sensitive.  ","version":"Next","tagName":"h2"},{"title":"Managing Documents​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#managing-documents","content":" The ObjectAPI documents are simple files on the file system. Several files can be processed together and form a system. It is convention that the file name matches the module name.  *.module.yaml | *.module.json - ObjectAPI document  Other files can be added which contain meta information for the API modules. They allow to inject additional information which is not relevant or available during API definitions.  *.module.meta.yaml | *.module.meta.json - ObjectAPI meta information injected into the relevant APIs.  So if a module is name org.example the ObjectAPI document should be called org.example.module.yaml  tip Outside of the ObjectAPI specification a solution document format is described which binds several modules together and links them to a code template for code generation.  ","version":"Next","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#data-types","content":" In the ObjectAPI specification data types are used in many locations. State, Method return types and parameters, signal parameters or structures.  Data fields are added at the same level to describe the data name and type. For example for the interface properties, these are:  properties: - name: count type: int   The general types available to ObjectAPI are:  Primitive Types: bool, int, int32, int64, float, float32, float64, stringContainer Types: arraysComplex Types : structures, enumerations  ","version":"Next","tagName":"h2"},{"title":"Primitives​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#primitives","content":" Data types can be re-presented in different forms in different programming languages. They all need to be convertible to JSON data types on request.  bool - A simple boolean value (true or false)int, int32, int64 - A signed integer valuefloat, float32, float64 - A floating point valuestring - A string value  ","version":"Next","tagName":"h2"},{"title":"Arrays​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#arrays","content":" An array is an index based list of primitive or complex data types. Further nesting of containers are not supported but can be achieved using structs as array items. A data type is converted into a container by setting the type to array and specifying the containing type in the items key.  For example an integer array can be noted like this:  properties: - name: names type: string array: true   If an array does contain a symbol as containing type, then the symbol name can be used in the items key.  properties: - name: messages type: Message array: true   Primitive types are always start with a lower case character and symbols always with an upper case character.  tip The code templates will change the casing based on the target language preferences.  ","version":"Next","tagName":"h2"},{"title":"Complex Types​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#complex-types","content":" A symbol is a named element inside a module. This can be either an interface, struct or enum/flag symbol.  structs: - name: Message   Inside the same module the type can be referenced by the name of the symbol using a ref. This holds true for all symbols.  properties: - name: msg1 type: Message - name: msg2 type: Message array: true   Outside the module, the module itself needs to be imported and the type needs to be used with its fully qualified name  imports: - org.example interfaces: - name: Interface1 properties: - name: msg1 type: org.example.Message   org.example.Message - external symbol  Note: Not every language profile does support importing.  ","version":"Next","tagName":"h2"},{"title":"Rich Text Formatting​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#rich-text-formatting","content":" Throughout the specification description support the markdown syntax. ","version":"Next","tagName":"h2"},{"title":"ObjectAPI IDL","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/idl","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#interfaces","content":" An interface defines a set of properties, operations and signals.  interface name { `prop-name` : type // property `method-name` ( params ): `type` // operation signal `signal-name` ( params ) // signal }   A type can be either a primitive type or a complex type. A complex type can be a structure, enumeration or another interface.  A primitive type can be one of the following:  bool : boolean valueint, int32, int64 : integer valuefloat, float32, float64 : floating point valuestring : string value  A complex type can be one of the following:  name of an interfacename of an enumerationname of a structure  To define arrays of a type just append the [] to the type.  struct Struct1 {} interface Demo { propString: string propStringArray: string[] propStruct: Struct1 }   tip Currently we do not support importing other modules. This is planned for a future version.  ","version":"Next","tagName":"h2"},{"title":"Structures​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#structures","content":" A data structure is a message which can be used to send complex information between objects. A structure is defined as follows:  struct name { fieldName : type }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#enumerations","content":" An enumeration is a set of named values. An enumeration is defined as follows:  enum Enum1 { Value1 = 0 Value2 = 1 Value3 = 2 }   A value can also be a hex number in the format of 0x2. If there is no value specified the next value is used.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#example","content":" Here is a complete example:  module demo 1.0 interface Radio { // frequency is the current frequency in MHz frequency: float // stations is a list of stations stations: Station[] // if enabled automatically tunes to the next station autoTune: bool // scan for stations scan() // tune to a specific frequency tuneFrequency(float frequency) // tune to a specific station tuneStation(stationId: int) // signal emitted when a new station is found signal stationFound(stationId: int) } struct Station { // id is the station id id: int // name of the station name: string // short name of the station shortName: string // frequency in MHz frequency: float // artwork url artwork: string // category of the content category: Category } enum Category { News = 0 Music = 1 Talk = 2 }   Our ApiGear tooling can create code in different languages. For example in C++ this would look like (simplified):  class Radio { public: // scan for stations void scan(); // tune to a specific frequency void tuneFrequency(float frequency); // tune to a specific station void tuneStation(int stationId); // signal emitted when a new station is found void onStationFound(function&lt;void(int stationId)&gt; callback); public: // frequency is the current frequency in MHz float frequency; // stations is a list of stations std::vector&lt;Station&gt; stations; // if enabled automatically tunes to the next station bool autoTune; }; struct Station { // id is the station id int id; // name of the station std::string name; // short name of the station std::string shortName; // frequency in MHz float frequency; // artwork url std::string artwork; // category of the content Category category; };  ","version":"Next","tagName":"h2"},{"title":"HTTP Mapping","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/mapping_http","content":"","keywords":"","version":"Next"},{"title":"ObjectAPI Mapping​","type":1,"pageTitle":"HTTP Mapping","url":"/docs/advanced/objectapi/mapping_http#objectapi-mapping","content":" module: Is a namespace and does not map directly.interface: /${module}/${interface} GET fetches the state of the interfacePOST sets the interface statePATCH partial update of the interface state operation: /${module}/${interface}/${operation} POST invokes the operation and returns the response  Structure are mapped like the normal JSON mapping of ObjectAPI data types. Same applies to enumerations. ","version":"Next","tagName":"h2"},{"title":"Use Cases","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/cases","content":"","keywords":"","version":"Next"},{"title":"Services​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#services","content":" When designing embedded platforms, it is often necessary to provide a state full design. The state is inherent from the device (e.g. temperature, location, current radio station). These states are often used by multiple applications. The applications are often not aware of each other and the state is not synchronized. This leads to a lot of duplicated code and a lot of complexity.  The protocol allows to share state between applications. ANd the state is automatically synced across applications and platforms. The applications can be written in different languages and can be running on different platforms. The protocol is designed to be used with the ObjectAPI specification. This allows to define a common API surface for the applications.  Protocol Features Used:  Property: read/write/notifyOperations: request/responseSignals: notify  ","version":"Next","tagName":"h2"},{"title":"Sensors​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#sensors","content":" A sensor can just use the property aspects of the protocol. The sensor can send property changes to the application. The application can then use the property changes to update the UI. For this the sensor does have to be linked to the remote object.  Protocol Features Used:  Property: write  ","version":"Next","tagName":"h2"},{"title":"Actuators​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#actuators","content":" An actuator can just use the property aspects of the protocol. The application can send property changes to the actuator. The actuator can then use the property changes to update the state of the actuator. For this the actuator has to be linked to the remote object to receive changes.  Protocol Features Used:  Property: notify  ","version":"Next","tagName":"h2"},{"title":"Remote Procedure Calls​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#remote-procedure-calls","content":" The protocol can be used to implement remote procedure calls. The protocol is designed to be used with the ObjectAPI specification. This allows to define a common API surface for the applications. The protocol can be used to implement a remote procedure call. The request is send to the service and the service replies with the result.  Additional the service can notify the client about events using the signal aspect of the protocol.  Protocol Features Used:  Operations: request/response  ","version":"Next","tagName":"h2"},{"title":"Highly Interactive Services​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#highly-interactive-services","content":" The protocol can be used to implement highly interactive services. For example for a whiteboard application the protocol can dynamically update the UI about the current location of the pen and it's state. Actions can be expressed as operations using the request/reply aspect of the protocol. The signals can be used to send a constant stream of events to the client.  Protocol Features Used:  Property: read/write/notifyOperations: request/responseSignals: notify ","version":"Next","tagName":"h2"},{"title":"Protocol Mappings","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/mapping","content":"","keywords":"","version":"Next"},{"title":"API Types​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#api-types","content":" There exists currently several API types, like REST, Message Based or RPC. ObjectAPI supports a mixture of these.  ","version":"Next","tagName":"h2"},{"title":"REST based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#rest-based-apis","content":" REST API is about browsing data but the underlying nature of the protocol is HTTP. HTTP is a request/response protocol and as such is architecture wise next to RPC. REST itself defines an architectural style on top of HTTP.  For example to increment a value this logic would be in REST like this.    We first fetch the counter state, than increment the count value and push back the result. The logic is on the client side and the service mostly manages data.  A typical API would look like this:  const client = new HttpClient(); const data = await client.get(&quot;/counter/$id&quot;); data.count += 1; await client.put(&quot;/counter/$id&quot;);   Often these kind of APIs makes it hard in complex logic driven services to validate operations and data.  ","version":"Next","tagName":"h3"},{"title":"Message based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#message-based-apis","content":" Message based APIs are typically realized using a message broker. The broker is responsible to ensure all messages are delivered to the subscribed or registered peers.    First we would subscribe to and interface state changes. Then we would publish the increment signal and wait for changes on the interface state. The changes are announces by the service via the broker.  A typical message based client would look like this:  const client = new MessageClient(); client.subscribe(&quot;/counter/$id&quot;); client.on(&quot;/counter/$id&quot;, (v) =&gt; { console.log(v); }); client.publish(&quot;/counter/$id/increment&quot;);   ","version":"Next","tagName":"h3"},{"title":"Object based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#object-based-apis","content":" Object based APIs focus on the developer API and take care of the internal mapping to the different protocol types. Interface properties will be typically automatically synced and signals will allow service side notifications to the clients.    The API for this would look like this.  const client = new CounterClient(); client.on((s) =&gt; { console.log(s.count); }); await client.increment();   First we register a callback when the interface state changes. Then we call the operation, as we defined an object API the API feels and works as developers would expect this.  This makes it much nicer and easier to use the API inside your application. The The API patterns is also extended to the service side, where service calls end into an API which looks very mich like the defined ObjectAPI. ","version":"Next","tagName":"h3"},{"title":"API Examples","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/examples","content":"","keywords":"","version":"Next"},{"title":"Counter​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#counter","content":" The typical counter example to increment and decrement a count value.  schema: apigear.module/1.0 name: org.example version: &quot;1.0&quot; info: title: &quot;Counter API&quot; description: A counter module develope interfaces: - name: Counter description: Counter interface to count up and down properties: - name: count type: int operations: - name: increment - name: decrement   ","version":"Next","tagName":"h2"},{"title":"Radio Tuner​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#radio-tuner","content":" A radio tuner with a current station and a station list. It can operate on different wavebands.  schema: apigear.module/1.0 module: entertainment.tuner version: 1.0 interfaces: - name: Tuner description: A tuner service to manages tuner stations properties: - name: currentStation type: Station description: current selected station - name: stationList type: Station[] description: list of current available stations operations: - name: nextStation description: sets current station to next station from list - name: previousStation description: sets current station to previous station from list - name: updateCurrentStation description: update current station params: - name: stationId - type: id structs: - name: Station fields: - name: stationId type: id description: station id - name: name type: string description: station name - name: modified type: string format: date-time description: station last time modified enums: - name: State description: State for tuner interface members: - name: None description: tuner not initialized - name: Loading description: tuner is loading - name: Ready description: tuner is ready and operational - name: Error description: tuner received an error - name: Waveband members: - name: FM description: FM waveband - name: AM description: AM waveband   ","version":"Next","tagName":"h2"},{"title":"Weather Station​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#weather-station","content":" The weather station uses a more compact YAML format to display the current temperature.  schema: apigear.module/1.0 module: sensors.weatherstation version: 2.5 interfaces: - name: WeatherStation - properties: - { name: temperature, type: float } - { name: lastError, type: Error } - operations: - { name: reset } - signals: - name: error params: - { name: error, type: Error } structs: - name: Error fields: - name: msg type: string  ","version":"Next","tagName":"h2"},{"title":"API Modules","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/modules","content":"","keywords":"","version":"Next"},{"title":"Module Namespaces​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#module-namespaces","content":" A module is a namespace for ObjectAPI symbols like interfaces, structures and enumerations. The module bundles these symbols together in one namespace.  A module is identified by its name and version. The module name should be typically lowercase and words separated by ., like a reverse URI notation org.example.  A module can have an additional info block to describe in more detailed the module information.  Typically a module consist of the apigear.interfaces version declaration, the module name and version, the list of interfaces, structures and signals.  The version number must be written as a string, otherwise it wil be converted to a numeric value (e.g. 1 for 1.0).  Only ObjectAPI, name, version are mandatory. The other identifiers are optional.  schema: apigear.module/1.0 name: org.example version: &quot;1.0&quot; interfaces: structs: enums:   ","version":"Next","tagName":"h2"},{"title":"Interfaces​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#interfaces","content":" An interface is the main instance to describe your software boundary using interface terms. The interface consist of state, operation and signals. The state is typically describe a a set of properties of the interface and operations modify the interface state. Signals notify the user of changes of the interface.  The interface itself is identified by its name inside a module.  schema: apigear.module/1.0 name: &quot;org.example&quot; version: &quot;1.0&quot; interfaces: - name: MyInterface   ","version":"Next","tagName":"h2"},{"title":"Object state​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#object-state","content":" Each property has a name and a type as also description and additional meta data.  # ... interfaces: - name: MyInterface properties: - name: value type: int   ","version":"Next","tagName":"h3"},{"title":"Operation​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#operation","content":" A operation defines the interaction with the interface. It is a collection of operations which can either manipulate the properties or return data.  Ideally you design your operations in a way that they can be divided into commands and queries. A command is an operation which does something on the interface and a query collects data from the interface and returns it to the user.  # ... interfaces: - name: MyInterface operations: - name: command description: A command does not have a return type - name: query type: string description: A query returns data   Operation can have parameter arguments  # ... interfaces: - name: MyInterface operations: - name: command params: - name: step type: int return: type: int   The arguments do parameterize the operation.  ","version":"Next","tagName":"h3"},{"title":"Signals​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#signals","content":" A signal allows the interface to notify the outside world about events happening, e.g. triggered by others. A signal is like an operation, but never defines a type.  # ... interfaces: - name: MyInterface signals: - name: error params: - name: code type: int   ","version":"Next","tagName":"h3"},{"title":"Data Structures​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#data-structures","content":" A structure represents a data structure which can be used for communication. The structure consists of a name and a set of data fields. Each field again has a name and a type information.  # ... structs: - name: Message fields: - name: msg type: string   A data structure does not contain any operations or signals. A data structure is typically used as a type for properties, operation parameters and others.  # ... interfaces: - name: MessageSender properties: - name: lastMessage type: Message operations: - name: send params: - name: msg type: Message   Data structure can be identified just be identified its name.  Data structures can be nested by using the type name of the nested type. In some programming languages care needs to be taken by the order of declaration.  ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#enumerations","content":" Enumerations and Flags are value types, which allow a user to use a defined number of choices to identify a value.  enums: - name: Status members: - name: None value: 0 - name: Loading value: 1 - name: Ready value: 2 - name: Error value: 3   The values are optional and when missing the value is counted incrementally from 0 on upwards.  enums: - name: Status members: - name: None - name: Loading - name: Ready - name: Error   An enumeration is also a symbol and can be used by its name to identify its type.  # ... interfaces: - name: MyInterface properties: - name: status type: Status # references the Status enumeration  ","version":"Next","tagName":"h2"},{"title":"Error Messages","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/errors","content":"","keywords":"","version":"Next"},{"title":"Error Codes​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#error-codes","content":" Error codes are string messages starting with olink.error. followed by a short description of the error. The following error codes are defined:  olink.error.invalid_message: the message is not a valid JSON arrayolink.error.invalid_message_type: the message type is not a valid integerolink.error.no_such_module: the module does not existolink.error.no_such_object: the object does not existolink.error.no_such_property: the property does not existolink.error.no_such_operation: the operation does not exist  tip Currently it is not possible to add details to the error message. This will be added in a future version.  ","version":"Next","tagName":"h2"},{"title":"Invalid Message​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#invalid-message","content":" The error message is send if the client sends an invalid message.  [ ERROR, 0, 0, &quot;olink.error.invalid_message&quot; ]   ","version":"Next","tagName":"h2"},{"title":"Invalid Message Type​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#invalid-message-type","content":" The error message is send if the client sends an invalid message type.  [ ERROR, 0, 0, &quot;olink.error.invalid_message_type&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Module​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-module","content":" The error message is send if the client tries to link to a non existing module.  [ ERROR, LINK, 0, &quot;olink.error.no_such.module&quot; ]   This error can also be send during an unlink operation if the module is not linked.  [ ERROR, UNLINK, 0, &quot;olink.error.no_such.module&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Object​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-object","content":" The error message is send if the client tries to link to a non existing object.  [ ERROR, LINK, 0, &quot;olink.error.no_such.object&quot; ]   This error can also be raised during an unlink operation if the object does not exists.  [ ERROR, UNLINK, 0, &quot;olink.error.no_such.object&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Property​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-property","content":" The error message is send if the client tries to set a property on a non existing property.  [ ERROR, SET_PROPERTY, 0, &quot;olink.error.no_such.property&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Operation​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-operation","content":" The error message is send if the client tries to invoke a non existing operation.  [ ERROR, INVOKE, 0, &quot;olink.error.no_such.operation&quot; ]  ","version":"Next","tagName":"h2"},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/lifecycle","content":"","keywords":"","version":"Next"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Lifecycle","url":"/docs/advanced/objectlink/lifecycle#sequence-diagram","content":" To link a local object to a remote object we need to send a link message.  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/intro","content":"","keywords":"","version":"Next"},{"title":"JSON Notation​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#json-notation","content":" Throughout the protocol description, the JSON notation is used. All data types must be valid JSON data types.  For transport several protocols are supported, see list below:  JSONMsgPackCBOR  The client and server needs to know their transport and encoding in advance. There is no protocol negotiation designed. This allows us to keep the protocol simple.  ","version":"Next","tagName":"h2"},{"title":"Message Types​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#message-types","content":" Lifecycle --&gt; LINK - link the local object with a remote object&lt;-- INIT - initialized the local object with properties from the remote object--&gt; UNLINK - unlinks a local object from a remote object Properties --&gt; SET_PROPERTY - send a property change to a remote object&lt;-- PROPERTY_CHANGE - sends property changes to all linked client objects Methods --&gt; INVOKE - invoke a method on a remote object&lt;-- INVOKE_REPLY - reply of an remote invokation Signals &lt;-- SIGNAL - send remote events back to all linked client objects Errors &lt;-- ERROR - send an error back to the client with the msg type of the original message  ","version":"Next","tagName":"h2"},{"title":"Message Formats​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#message-formats","content":" Direction\tMessage\tValue\tFormat-&gt;\tLINK\t10\t[ MsgType, ObjectId ] &lt;-\tINIT\t11\t[ MsgType, ObjectId, Dict ] -&gt;\tUNLINK\t12\t[ MsgType, ObjectId ] -&gt;\tSET_PROPERTY\t20\t[ MsgType, PropertyId, Value ] &lt;-\tPROPERTY_CHANGE\t21\t[ MsgType, ObjectId, Value ] -&gt;\tINVOKE\t30\t[ MsgType, RequestID, MethodId, Args ] &lt;-\tINVOKE_REPLY\t31\t[ MsgType, RequestID, Value ] &lt;-\tSIGNAL\t40\t[ MsgType, SignalId, Args ] &lt;-\tERROR\t50\t[ MsgType, MsgType, RequestID, Error ]  MsgType: integer value of message typeObjectId: a string identifying the resource as module and object name (e.g. &quot;demo.Calc&quot;)Dict: A JSON dictionary, e.g. { &quot;count&quot;: 0}Args: A JSON array, e.g. [ 1, 2 ]PropertyId: A ObjectID with a property path (e.g. &quot;demo.Calc/count&quot;)Value: Any valid JSON value including JSON arrays or objectsMethodId: A ObjectID with a method path (e.g. &quot;demo.Calc/increment&quot;)RequestId: A unique integer value identifying the request during the connection. Typically a value incremented by one on each request and starting by 1 and then reset to 1 by max value.SignalId: A ObjectID with a signal path (e.g. &quot;demo.Calc/shutdown&quot;)Error: A string describing the error ","version":"Next","tagName":"h2"},{"title":"Method Invokation","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/methods","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#apigear-object-model","content":" To model methods in ApiGear you define an interface with operations.  name: org.demos interfaces: - name: Echo operations: - name: say params: - name: msg type: string type: string   The operations will be generated as methods of the object. This will look simplified like this.  // org.demos.js class Echo { async say(msg: string): string } const echo = new Echo() console.log(echo.say(&quot;hello&quot;)) $&gt; hello   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#protocol-flow","content":" To invoke remote method an method name and the method arguments must be specified. The reply can only have on value, which can have any complexity.  The local object sends an INVOKE message to the remote object using a request id, the method name and method arguments.  --&gt; [ INVOKE, 1, &quot;org.demos.Echo/say&quot;, [&quot;echo&quot;]]   The remote object executes the method and returns the reply or an error message in case of failure.  &lt;-- [ INVOKE_REPLY, 1, &quot;echo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#sequence-diagram","content":" After an object is linked remote methods can be called.  ","version":"Next","tagName":"h2"},{"title":"Property Synchronization","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/properties","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#apigear-object-model","content":" In ApiGear properties are described as properties inside an interface.  name: org.demos interfaces: - name: Echo properties: - name: message type: string   The resulting simplified typescript code could look like this.  // org.demos.js class Echo { message: string = &quot;&quot; } const echo = new Echo() echo.message = &quot;foo&quot;   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#protocol-flow","content":" First the local object needs to be linked to a remote object.  --&gt; [ LINK, &quot;org.demos.Echo&quot;]   Now the local object receive initial property list, which is automatically send after the link message.  &lt;-- [ INIT, 'org.demos.Echo', { message: &quot;hello&quot; } ]   After the init message out local object is fully populated and all properties have valid values.  When a property is changed on the local object, for example from &quot;hello&quot; to &quot;foo&quot;, a SET_PROPERTY message is send.  --&gt; [ SET_PROPERTY, &quot;org.demos.Echo/message&quot;, &quot;foo&quot;]   The remote object will then set the property and notify all linked objects about the changes using a PROPERTY_CHANGE message, including the original sender.  &lt;-- [ PROPERTY_CHANGE, &quot;org.demos.Echo/message&quot;, &quot;foo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#sequence-diagram","content":" After an object is linked propertie will be synced across all linked clients.  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/intro","content":"","keywords":"","version":"Next"},{"title":"What is a simulation?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation","content":" A simulation is a virtual representation of a service. It can be used to test, demonstrate or develop applications without the need to have the actual service available.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation server?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-server","content":" A simulation server is a server which hosts one or more simulations in form fo scenarios. It can be used to test, demonstrate or develop applications without the need to have the actual service available.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation scenario?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-scenario","content":" A simulation scenario is a set of interfaces and their properties, operations, signals which can be loaded into a simulation server. A scenario can react to operations and can also be used to change properties or send signals.  A scenario allows also to define sequences of actions which can be triggered by an operation call or by name. The actions can change the property values of the service or send signals.  Simulation scenarios can be written using a YAML schema.  Based on our counter demo we can write a YAML based scenario like this.  schema: apigear.scenario/1.0 name: &quot;demo scenario&quot; version: &quot;1.0&quot; interfaces: - name: demo.Counter: properties: count: 0 operations: - name: increment: actions: - $set { count: 10 } - name: decrement: actions: - $set { count: -10 } - name: demo.Echo: operation: - name: say: actions: - $return { result: &quot;Hello World&quot; }   This is a simple scenario which imitate a demo.Counter and demo.Echo interface.  When this scenario is loaded into the simulation server a client can just call these simulation operations. This scenario does not include sequences.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation protocol?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-protocol","content":" A simulation protocol is a way to interact with a simulation server. It defines how to call operations, how to get the state of an interface and how to trigger sequences. The simulation server currently supports the ObjectLink protocol which is available in the ObjectLink section. ","version":"Next","tagName":"h2"},{"title":"Server Side Signals","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/signals","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#apigear-object-model","content":" Signals can be modeled using ApiGear as signals of an interface.  name: org.demos interfaces: - name: Echo signals: - name: shutdown params: - name: timeout type: int   The resulting code will look somehow like this and most often will require a lambda function to be used for the notification.  // org.demos.js class Echo { onShutdown(callback) } const echo = new Echo() echo.onShutdown( (timeout) =&gt; { console.log('timeout: ', timeout); })   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#protocol-flow","content":" To receive signals the local object needs to be linked to the remote object first.  --&gt; [ LINK, &quot;org.demos.Echo&quot;]   Then the remote object can send at any time signals to the linked client objects and notify them on changes.  &lt;-- [ SIGNAL, &quot;org.demos.Echo/shutdown&quot;, [10]]   To stop receiving signals, just unlink the remote object.  --&gt; [ UNLINK, &quot;org.demos.Echo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#sequence-diagram","content":" After an object is linked server side signals will be send.  ","version":"Next","tagName":"h2"},{"title":"Scenario Documents","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/scenario","content":"","keywords":"","version":"Next"},{"title":"Action​","type":1,"pageTitle":"Scenario Documents","url":"/docs/advanced/simulation/scenario#action","content":" At several places the scenario uses action sequences. A sequence is a list of actions each action is an object with a key of the action command and a array value as the action arguments.  - $cmd: { cmd-options }   When an action modifies a property, the property change signal is emitted automatically.  Typical actions are  $set - sets a value - $set: { count: 1 }similar to set('count', 1) $signal - emits a signal from the simulation - $signal: { shutdown: { timeout: 5 } }similar to emit signal('shutdown', { timeout: 5} ) $return - returns a result from an operation: - $return: { count: 1 }similar to return { count: 1 }  ","version":"Next","tagName":"h2"},{"title":"Sequences​","type":1,"pageTitle":"Scenario Documents","url":"/docs/advanced/simulation/scenario#sequences","content":" A sequence is a list of actions, organized into steps. Each step is executed in order. Actions of a step are also executed in order. A sequence can be looped or stepped through using an interval.   ```yaml sequence: - name: increment counter interval: 2000 # 2 seconds loop: true # start over when at end steps: # step is called every 2 secs according to interval - name: increment actions: # list of actions - $set: { count: 1 } - $signal: { shutdown: [ 5 ] } - name: clear actions: - $set: { count: 0 } - $signal: { shutdown: [ 5 ] } }   The interval defined the tick and on each tick a step is running. If loops is true then the playbook will start again after finished. ","version":"Next","tagName":"h2"},{"title":"Network Protocol","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/protocols","content":"","keywords":"","version":"Next"},{"title":"Example​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#example","content":" In the following we will use always our counter example which looks like this:  schema: apigear.module/1.0 name: demo version: &quot;1.0&quot; interfaces: - name: Counter properties: - name: count type: int operations: - name: increment params: - name: step type: int - name: decrement params: - name: step type: int - name: Echo operations: - name: say params: - name: message type: string return: - type: string   We can identify an operation using an URI like this demo.Counter/increment and a service like this demo.Counter.  As a convention, calling the service should always give back the current state, which is the sum of properties. Calling an operation should always return a valid value defined by the return type.  ","version":"Next","tagName":"h2"},{"title":"ObjectLink Protocol for Simulation​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#objectlink-protocol-for-simulation","content":" The simulation server can be called using the ObjectLink protocol over WebSockets. The protocol is described in the ObjectLink specification.  An incoming object link message is wired to a scenario document. Each scenario document can contain multiple interfaces. The interface name is used to identify the interface to be simulated. The operation name is used to identify the operation to be simulated. In case no scenario document is provided, the simulation server will use a default scenario document.  ","version":"Next","tagName":"h2"},{"title":"Feeding the Simulation Server​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#feeding-the-simulation-server","content":" The simulation server can be fed with a a set of JSON messages arranged in a new-line separated JSON file. The file can be provided using the --feed command line option of the CLI. The file can be used to feed the simulation server with a set of messages. The messages are sent to the simulation server in the order they are provided in the file. The file can be used to feed the simulation server with a set of messages. The messages are sent to the simulation server in the order they are provided in the file.  Feeding a simulation server is a great way to validate your simulation scenario or even your object-link service. ","version":"Next","tagName":"h2"},{"title":"Simulation with Studio","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/studio","content":"","keywords":"","version":"Next"},{"title":"Connection​","type":1,"pageTitle":"Simulation with Studio","url":"/docs/advanced/simulation/studio#connection","content":" To connect to the ApiGear Studio simulation server you need to know the connection address, which can be queries from the settings panel.  The connection address in the form of ws://127.0.0.1/5554 or parts of it needs to be made available to your API SDK. Please consult the dedicated SDK readme about the correct procedure.  ","version":"Next","tagName":"h2"},{"title":"Monitoring​","type":1,"pageTitle":"Simulation with Studio","url":"/docs/advanced/simulation/studio#monitoring","content":" There is no dedicated view for monitoring the simulation calls. These calls can be monitored using the API monitor as part of the API calls. ","version":"Next","tagName":"h2"},{"title":"Actions Reference","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/actions","content":"","keywords":"","version":"Next"},{"title":"$set​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#set","content":" The $set action sets a value of a property. The default case it sets the value of the default interface. The value can be a primitive or a object.  # set the property `count` to `0` $set: { count: 0 }   Or using an object  # set the property `position` to `{ x: 10, y: 20 }` $set: { position: { x: 10, y: 20 } }   The set command will change the property value and also emit a property change signal. The change signal is emitted automatically when a property is changed using the $set action.  ","version":"Next","tagName":"h2"},{"title":"$update​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#update","content":" The $update action updates a partial value of a property. The default case it updates the value of the default interface. The value can be a primitive or a object. Different from $set the value is merged with the existing value.  This is useful when the value is an object and only a part of the object needs to be changed.  # set the property `position` to `{ x: 10, y: 20 }` - $set { position: { x: 10, y: 20 } } # partially update the property `position` property to `{ x: 30, y: 20 }` - $update { position: { x: 30 } }   ","version":"Next","tagName":"h2"},{"title":"$signal​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#signal","content":" The $signal action emits a signal from the simulation. The default case it emits the signal from the default interface. The value is an array of arguments, which are the arguments of the signal, as defined in the API.  For example a signal shutdown with an argument timeout can be emitted like this:  # emit the signal `shutdown` with the argument `timeout` set to `5` $signal: { shutdown: [ 5 ] } x   note To directly emit a signal from the client it is possible to use invoke operation, but with a $signal. prefix of the signal name. For example to emit the shutdown signal from the client it can be done like this: client.invoke(&quot;$signal.shutdown&quot;, [ 5 ]) This will send the invoke message to the simulation and the simulation will emit the signal. There is no return value from the invoke operation.  ","version":"Next","tagName":"h2"},{"title":"$return​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#return","content":" The $return action returns a result from an operation. The default case it returns the result from the default interface. The value to return is given in the result key of the action object.  For example a result 1 from an operation it can be returned like this:  # returns the result `1` from the operation $return: { result: 1 }   To return an object as result, use the result key:  note If several return commands are used in a step, only the last one is returned.  # will return the result `{ x: 10, y: 20 }` from the operation $return: { result: { x: 10, y: 20 } }   The receiving client must know the type of the result to be able to parse it.  ","version":"Next","tagName":"h2"},{"title":"$change​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#change","content":" The $change action emits a property change signal from the simulation. The default case it emits the signal from the default interface. The value is property name and the new value.  # emits the property change signal `count` with value `1` $change: { count: 1 }   The change command will not change the property. It is used to simulate a property change from the outside. The change signal is emitted automatically when a property is changed using the $set action.  It is also possible to change several properties at once:  # emits the property change signal `count` and 'position' with their values $change: { count: 1, position: { x: 10, y: 20 } }   ","version":"Next","tagName":"h2"},{"title":"$call​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#call","content":" The $call action calls an operation from the simulation. The default case it calls the operation from the default interface. The value is the operation name and the arguments.  # calls the operation `increment` with the argument `1` inside the simulation $call: { increment: [1] }   note You need to make sure you do not recurse into an infinite loop, by calling an operation that calls the same operation again.  You can also call several operations at once. We can currently not guarantee the order of operations. The last operation result is returned. If an error occurs, the error is returned and no result.  # will call the operation `increment` with the argument `1` # and then call the operation `decrement` with the argument `1` $call: { increment: [1], decrement: [1] }  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/cli/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/docs/cli/intro#installation","content":" The apigear command line tool is available for Linux, MacOS and Windows. It can be installed from the release page.  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Introduction","url":"/docs/cli/intro#update","content":" The apigear command line tool can be updated using the update command.  apigear update   It will ask for confirmation and then download the latest version of the apigear command line tool. ","version":"Next","tagName":"h2"},{"title":"Code Generation","type":0,"sectionRef":"#","url":"/docs/cli/generate","content":"","keywords":"","version":"Next"},{"title":"Quick Code Generation​","type":1,"pageTitle":"Code Generation","url":"/docs/cli/generate#quick-code-generation","content":" The apigear command line tool can be used to generate code from an API definition. The following example shows how to generate code from the a demo API definition.  // demo.idl module demo 1.0 interface Counter { count: int increment() decrement() }   For example to generate a C++ 14 SDK from the demo API definition just run the following command.  apigear generate expert -i demo.idl -o tmp -t apigear-io/template-cpp14   The expert mode is used to generate code from an IDL file. The -i option specifies the input file. The -o option specifies the output directory. The -t option specifies the template to use. The template-cpp14 template is used to generate C++ 14 code.  If the template does not point to a local directory the template will be downloaded from the template registry and installed in a local cache directory.  By default the latest version of the template is used. To use a specific version of the template add the version to the template name using the @&lt;version&gt; syntax.  ","version":"Next","tagName":"h2"},{"title":"Solution based Code Generation​","type":1,"pageTitle":"Code Generation","url":"/docs/cli/generate#solution-based-code-generation","content":" To streamline the code generation you can create a configuration file called solution. The following example shows how to create a configuration file for the C++ 14 SDK.  # solution.yaml layers: - name: cpp14 inputs: - demo.idl output: tmp template: template-cpp14   The layers section defines the layers of the solution. Each layer defines a set of inputs, an output directory and a template. The inputs section defines the input files for the layer. The output section defines the output directory for the layer. The template section defines the template to use for the layer.  To generate the code from the solution just run the following command.  apigear generate solution solution.yaml  ","version":"Next","tagName":"h2"},{"title":"API Monitoring","type":0,"sectionRef":"#","url":"/docs/cli/monitor","content":"","keywords":"","version":"Next"},{"title":"Quick API Monitoring​","type":1,"pageTitle":"API Monitoring","url":"/docs/cli/monitor#quick-api-monitoring","content":" API Monitoring is a feature of the ApiGear platform. It allows to monitor the traffic of an API. The apigear command line tool can be used to monitor an API. The following example shows how to monitor the demo API.  apigear monitor run   This will start the API monitoring server. The server will listen on port 5555. To change the port use the --port option.  The monitoring server will listen for API calls. Normally the API events will come from a running API client. It is also possible to feed API events using the feed command.  The following example shows how to feed API event to the monitor using a new line delimited json document (NDJSON).  // demo.ndjson { &quot;id&quot;: &quot;1&quot;, &quot;kind&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;demo.Counter/increment&quot; } { &quot;id&quot;: &quot;2&quot;, &quot;kind&quot;: &quot;state&quot;, &quot;symbol&quot;: &quot;demo.Counter&quot;, &quot;props&quot;: { &quot;count&quot;: 99 } } }   apigear monitor feed demo.ndjson   This will send the API calls to the monitoring server. The monitoring server will print the API calls to the console.  tip Currently the monitoring server does not store the API calls. This will be added in a future release with a playback feature. ","version":"Next","tagName":"h2"},{"title":"Help","type":0,"sectionRef":"#","url":"/docs/community/help","content":"","keywords":"","version":"Next"},{"title":"SDK Templates","type":0,"sectionRef":"#","url":"/docs/cli/template","content":"","keywords":"","version":"Next"},{"title":"Search Templates​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#search-templates","content":" You can search for templates using the apigear template search command. The command will search for templates in the cloud and print the result.  apigear template search &lt;name&gt;   The name argument is optional. If you specify a name the command will search for templates with a matching name. If you omit the name the command will search for all templates.  ","version":"Next","tagName":"h2"},{"title":"Install a Template​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#install-a-template","content":" To install a template you need to know the name of the template. The name is the same as the name of the template in the ApiGear Registry. You can find the name in the template details page.  apigear template install &lt;name&gt;   The name argument is the name of the template. The command will install the template in the local template folder. The default location is ~/.apigear/templates. You can change the location using the APIGEAR_TEMPLATES environment variable.  Template Info  You can get information about a template using the apigear template info command. The command will print the details of the template.  apigear template info &lt;name&gt;   The information includes the name, version, description and features of the template.  Update a Template  To update a template you need to know the name of the template. The name is the same as the name of the template in the ApiGear Registry. You can find the name in the template details page.  apigear template update &lt;name&gt;   The update will update to the latest version by default but it's also possible to specify a version.  ","version":"Next","tagName":"h2"},{"title":"Remove a Template​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#remove-a-template","content":" You can remove a template by name. The name can be found using the list command.  apigear template remove &lt;name&gt;   ","version":"Next","tagName":"h2"},{"title":"List Installed Templates​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#list-installed-templates","content":" You can list all installed templates using the apigear template list command. The command will print the name and version of all installed templates.  apigear template list  ","version":"Next","tagName":"h2"},{"title":"How to get help​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-get-help","content":" Asks question in the GitHub discussion forum or issue tracker.  Slack DiscussionsGitHub DiscussionsGitHub Issues  ","version":"Next","tagName":"h2"},{"title":"How to report a bug​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-report-a-bug","content":" Report a bug in the GitHub issue tracker. Please include the following information:  Version of the CLI Steps to reproduce the bug Expected behavior Actual behavior GitHub Issues  ","version":"Next","tagName":"h2"},{"title":"How to request a feature​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-request-a-feature","content":" Request a feature in the GitHub issue tracker. Please include the following information:  Description of the feature Use case for the feature Alternatives considered GitHub Issues ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/docs/cli/project","content":"","keywords":"","version":"Next"},{"title":"Create a new project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#create-a-new-project","content":" To create a project use the new command.  apigear project new &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"List recent projects​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#list-recent-projects","content":" To list all projects use the list command.  apigear project list   It will show the recently used projects first.  ","version":"Next","tagName":"h2"},{"title":"Delete a project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#delete-a-project","content":" To delete a project use the delete command.  apigear project delete &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"Switch between projects​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#switch-between-projects","content":" To switch between projects use the switch command.  apigear project switch &lt;project-name&gt;   It will switch the current project to the specified project.  ","version":"Next","tagName":"h2"},{"title":"Project configuration​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#project-configuration","content":" The project command stores the project configuration in the &lt;project&gt;/.apigear file. The configuration file contains the following information.  # .apigear { &quot;folder&quot;: &quot;apigear&quot;, }   The folder property specifies the folder where the project configuration is stored. The default value is apigear.  ","version":"Next","tagName":"h2"},{"title":"Create documents in the project folder​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#create-documents-in-the-project-folder","content":" The create command allows you to create documents in the project folder. The following documents can be created: API Modules, API Solutions and API Scenarios.  apigear create &lt;document-type&gt; &lt;document-name&gt;   The document will be created in the apigear folder of the current project. The document-type can be one of the following values: module, solution or scenario.  ","version":"Next","tagName":"h2"},{"title":"Pack a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#pack-a-project","content":" The pack command allows you to pack a project. It will create a zip file containing all project documents.  apigear project pack &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"Share a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#share-a-project","content":" The share command allows you to share a project. It will create a zip file containing all project documents and upload it to the ApiGear platform.  apigear project share &lt;project-name&gt;   tip This feature is currently not available and will be added in a future release.  ","version":"Next","tagName":"h2"},{"title":"Import a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#import-a-project","content":" The import command allows you to import a project. It will download a zip file containing all project documents from the ApiGear platform and unpack it.  apigear project import &lt;project-name&gt;   tip This feature is currently not available and will be added in a future release. ","version":"Next","tagName":"h2"},{"title":"API Simulation","type":0,"sectionRef":"#","url":"/docs/cli/simulate","content":"","keywords":"","version":"Next"},{"title":"Quick API Simulation​","type":1,"pageTitle":"API Simulation","url":"/docs/cli/simulate#quick-api-simulation","content":" API Simulation is a feature of the ApiGear platform. It allows to simulate the behavior of an API. The apigear command line tool can be used to simulate an API. The following example shows how to simulate the demo API.  API simulation is based on a simulation scenario. The following example shows how to create a simulation scenario for the demo API.  # demo.scenario.yaml interfaces: - name: demo.Counter props: count: 0 operations: - name: increment actions: - $set: { count: 1 } - name: decrement actions: - $set: { count: 0 }   Now we can run the simulation server using the following command.  apigear simulate run demo.scenario.yaml   The simulation server will listen on port 5555. To change the port use the --port option. It will load the simulation scenario from the demo.scenario.yaml file. The simulation server will listen for API calls. Normally the API calls will come from a running API client. It is also possible to feed API calls using the feed command.  The following example shows how to feed API calls to the simulation server using a new line delimited json document (NDJSON).  { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot; }} { &quot;method&quot;: &quot;simu.call&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter/increment&quot;, &quot;data&quot;: { &quot;step&quot;: 1 } }} { &quot;method&quot;: &quot;simu.call&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter/decrement&quot;, &quot;data&quot;: { &quot;step&quot;: 2 } }} { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot;, &quot;data&quot;: { &quot;count&quot;: 4 } }} { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot; }}   To feed the API calls to the simulation server just run the following command.  apigear simulate feed demo.ndjson   This will send the API calls to the simulation server. The simulation server will print the API calls to the console. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is ApiGear?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-apigear","content":" ApiGear is a set of tools and services that allow teams to create a description of their software interfaces and generate a ready to use integration SDK. The SDK comes already pre-configured with support for monitoring, logging, and tracing and simulation of interface calls.  ","version":"Next","tagName":"h2"},{"title":"What is an API?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-an-api","content":" An API is a set of rules that define how software components communicate with each other. It is a contract between the software components. The API defines the data structure and the behavior of the software components. It is a description of the software interfaces.  ","version":"Next","tagName":"h2"},{"title":"What is an API Module?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-an-api-module","content":" An API module is a description of an API. It is a document that contains the API description. It is a description of the software interfaces. A set of modules define a software system. The modules are the building blocks of the system. API modules can be transformed into SDKs using the ApiGear Studio and the ApiGear CLI.  ","version":"Next","tagName":"h2"},{"title":"What is an API SDK?​","type":1,"pageTitle":"Introduction","url":"/docs/intro#what-is-an-api-sdk","content":" An API SDK is a set of software components that reflect the API module content. It allows to focus on the API usage and less on the implementation details. The SDK is a ready to use integration component that can be used to integrate the software system with other systems. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/guide/intro","content":"","keywords":"","version":"Next"},{"title":"Development Cycle​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#development-cycle","content":" This is section is about how to use ApiGear to create SDKs with the ObjectAPI.  tip Feel free to jump directly to our demos over at github. They showcase two different APIs in several languages including applications which use the API modules.  Now, that you know the basics about the ObjectAPI and how to create SDKs using ApiGear, we provide some demos and hints for real world projects.  We will cover starting from scratch as well as updating an existing API, previously created using ApiGear. Our demos are implemented using the same process as described below.  ","version":"Next","tagName":"h2"},{"title":"Cycle Overview​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#cycle-overview","content":"   The graphic describes the development cycle using ApiGear.  Like every modern development tool ApiGear fully supports an agile development approach. You can start with a minimal API definition and then iteratively add more functionality or change existing details. Theoretically, you could even rewrite the whole API. However, using the API first approach will help you design more stable and high quality APIs.  ","version":"Next","tagName":"h2"},{"title":"Define API​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#define-api","content":" As with every API first approach you start at defining your ObjectAPI module. This can be done using the ApiGear Studio or the ApiGear CLI. An API module is a simple document following the ObjectAP specification.  ","version":"Next","tagName":"h2"},{"title":"Create SDK​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#create-sdk","content":" Once you have created one or several API modules you are set to create your first SDK. Therefore you choose one of our expert engineered SDK templates and a SDK runner for your project.  The SDK runner will create a .zip file for you to download.  ","version":"Next","tagName":"h2"},{"title":"Apply Changes​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#apply-changes","content":" The aforementioned SDK .zip file consists of several different files depending on the SDK runner setup and chosen programming language.  Assuming you chose the &quot;full package including scaffolding&quot; then you have the following types of files:  The plain API in your preferred languageA stub implementation derived from this API with a basic implementationA suite of test files covering the stub implementationProject files to instantaneously build the whole API module and execute the test casesAdditional adapters created by ApiGear to provide API analytics insights.  From here on we recommend a split strategy depending on whether you created the API module for the first time or whether you want to update an existing implementation.  ","version":"Next","tagName":"h2"},{"title":"First run​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#first-run","content":" The easiest way to set your project up for long time API updates is to create an ini(tial) folder within your project and extract the SDK unmodified in this folder. Afterwards you just simply copy this ini folder to a sol(ution) folder. You should then commit this state as initial version to be able to always rollback.  Once this is done you can start replacing the API stub implementation in the sol folder with your business logic and the same time update the test stubs to cover the real API behavior.  ","version":"Next","tagName":"h3"},{"title":"Updating existing APIs​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#updating-existing-apis","content":" When you have set up your project as described in the first run using a ini and sol folder - or a similar setup - you can now easily apply updates to your API using the following steps.  extract the updated SDK unmodified into the ini folder. A diff of your preferred source control tool should only should the auto generated changes based on your API modificationuse a compare and merge tool to go over the differences of the updated ini folder and your existing implementation in the sol folderonly apply the interface changes without overwriting your business logic  This process might sound cumbersome on first sight but is really easy and straight forward to use.  ","version":"Next","tagName":"h3"},{"title":"Create application​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#create-application","content":" Now, that we have our API module in place we can start using it an application. Depending on whether it is the same team or a different team implementing the application, they can use the module either with a stub implementation, a simulation adapter or the real business logic. There is no dependency anymore - the API module and the application can be both developed in parallel based on the commonly defined API description.  Our demos were developed the same way as described above. Small increments at a time, super fast and with high quality built in. The applications are stored in the app(lication) folder.  ","version":"Next","tagName":"h2"},{"title":"Gain insights​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#gain-insights","content":" With the upcoming feature ApiGear analytics you will gain full insight into your customers API usage. Based on this highly valuable feedback you are able to make fully informed decisions on which feature to extend or which could be spared for future efficiency and customer satisfaction. ","version":"Next","tagName":"h2"},{"title":"Calculator API Demo","type":0,"sectionRef":"#","url":"/docs/guide/calculator","content":"","keywords":"","version":"Next"},{"title":"Defining an API Module​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#defining-an-api-module","content":" From inside a project we create a new API module called demo.calc using the Create Module action and create a new interface named 'Calculator'.  schema: apigear.module/1.0 name: demo.calc version: &quot;1.0&quot; interfaces: - name: Calculator   A typical calculator always displays the current value calculated. We will add this as a property to the interface.  interfaces: - name: Calculator properties: - name: value type: int   We expect the value is always updated when a number was entered and a new operation is entered.  We add the first operation add to the calculator. It takes one parameter and the number to be added.  interfaces: - name: Calculator operations: - name: add params: - name: a type: int   Let's add the rest of the calculator operations and the clear action.  schema: apigear.module/1.0 name: demo.calc version: &quot;1.0&quot; interfaces: - name: Calculator properties: - name: value type: int operations: - name: add params: - name: a type: int - name: subtract params: - name: a type: int - name: multiply params: - name: a type: int - name: divide params: - name: a type: int - name: clear   We added all missing calculator operations. The clear action will reset the calculator value to 0.  ","version":"Next","tagName":"h2"},{"title":"Python Interface​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#python-interface","content":" For our implementation we configure a Python SDK as runner and generate our calculator SDK. The abstract calculator interface will look like this:  # demo_calc.py class AbstractCalculator(object): def __init__(self): self.value = 0 def add(a: int): raise NotImplementedError def subtract(a: int): raise NotImplementedError def multiply(a: int): raise NotImplementedError def divide(a: int): raise NotImplementedError def clear(a: int): raise NotImplementedError   ","version":"Next","tagName":"h2"},{"title":"Sample Implementation​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#sample-implementation","content":" To implement the interface we derive from the abstract calculator and implement the missing operations. A simple implementation could look like this.   # import our generated interfaces import org_daily class Calculator(demo_calc.AbstractCalculator): def add(a: int): self.value += a def subtract(a: int): self.value -= a def multiply(a: int): self.value *= a def divide(a: int): self.value /= a def clear(a: int): self.value = 0   ","version":"Next","tagName":"h2"},{"title":"API Updates​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#api-updates","content":" The next time we change the API module we need to update the abstract interface and ensure all changed operations are implemented.  It is very easy now to add implementations also for other programming languages or even for a micro service using one of the many supported SDK templates. ","version":"Next","tagName":"h2"},{"title":"Counter API Demo","type":0,"sectionRef":"#","url":"/docs/guide/counter","content":"","keywords":"","version":"Next"},{"title":"Using the API​","type":1,"pageTitle":"Counter API Demo","url":"/docs/guide/counter#using-the-api","content":" The generated code will result in a C++ class with some abstract methods. The API has no functionality yet, and needs to be provided by you. So open the project in your favorite editor and add the implementation.  // counter.h void Counter::increment() { // add implementation here count++; }   Now, you can use the class in your main function.  // main.cpp #include &lt;iostream&gt; using namespace std; #include &quot;counter.h&quot; int main(int argc, char**argv) { Counter counter; cout &lt;&lt; counter.count(); counter.increment(); cout &lt;&lt; counter.count(); }   Which concrete API you will use depends on the code generators you configure. There are code-generators for many languages and technologies available.  We can now continue to design the API inside the APIGear's API editor.  The editor allows us to save the API at any point and to create a new version if required.  ","version":"Next","tagName":"h2"},{"title":"Documentation​","type":1,"pageTitle":"Counter API Demo","url":"/docs/guide/counter#documentation","content":" To make the API more descriptive we can add some description.  The API language has full support for markdown based descriptions.  To write code examples just indent the code snippets  schema: apigear.module/1.0 name: demo.daily version: &quot;1.0&quot; description: A module to demonstrate an API interfaces: - name: Counter description: An interface to increment a coffee counter properties: - name: count type: int description: holds the current count value operations: - name: increment description: increments the count value   After saving the API module, we can see the documentation in the API portal. It is automatically updated, based on the API module content.  Now, we have successfully defined an API. The next step will be to use the API. First in a playground like environment, later in a real project. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/sdk/intro","content":"Introduction ApiGear comes with a collection of SDK templates which allows our users to create code interfaces but also complete SDKs from the API Modules. A template is a transformation of a group of API modules into source code for your software project. All template SDKs can scale with your project by adding more API modules. A command line tool will support you with merging the updated SDK code. These templates can be configured by enabling and disabling certain features. Also SDKs are build on top of certain ObjectAPI profiles, which enable or disable certain language features. A user will get a warning when an API uses features not available in the configured language profile. An SDK will come with all build and test related dependencies and ready to use for your project. The SDK scales with your requirements by adding more API modules which are automatically added to the build infrastructure and tests. ApiGear offers currently several SDKs for major programming languages and technologies and more will come over time.","keywords":"","version":"Next"},{"title":"Golang SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/go-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  type Counter interface { GetCount() int SetCount(count int) Increment() }   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Go struct type. As these API structs shall be able to be used outside of the module the fields are public.  type Message struct { Text string = &quot;&quot; }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  type Direction int const ( Up = 1 Down = 2 Left = 3 Right = 4 )  ","version":"Next","tagName":"h2"},{"title":"C++ 14 SDK template","type":0,"sectionRef":"#","url":"/docs/sdk/cpp14-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class CounterBase { public: CounterBase(){}; virtual ~CounterBase(){}; // methods virtual void increment() = 0; // property methods virtual void setCount(int count) = 0; virtual int count() const = 0; };   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Qt C++ class with public fields.  class Message { public: Message(); void setText(const std::string&amp; text); std::string text() const; bool operator==(const Message &amp;other) const; bool operator!=(const Message &amp;other) const; private: std::string m_text; };   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#enumerations","content":" A enumeration will be transformed to a standalone class with an enum embedded.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  class Direction { public: Direction() {} enum DirectionEnum { Up = 0, Down = 1, Left = 2, Right = 3 }; static DirectionEnum toEnum(std::uint8_t v, bool *ok); };  ","version":"Next","tagName":"h2"},{"title":"Python SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/python-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class ICounter: @property def count(self): raise NotImplementedError def increment(self): raise NotImplementedError   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a python class. As these API structs shall be able to be used outside of the module the fields are public.  class Message: def __init__(self): self.text : str = str()   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  from enum import Enum class Direction(Enum): Up = 0 Down = 1 Left = 2 Right = 3  ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/start/install","content":"","keywords":"","version":"Next"},{"title":"Install Apigear Studio​","type":1,"pageTitle":"Installation","url":"/docs/start/install#install-apigear-studio","content":" ApiGear Studio can be downloaded from Github Releases Site. Studio is available for Mac, Windows and Linux.  After installation you can start the ApiGear Studio.  caution ApiGear Studio is Early Access Software and should not be used for production yet. We are working to finalize the product and will release a stable version soon.  As ApiGear Studio is still in early access version there are no certificates yet. Which requires you on Windows and MacOS to accept some exceptions.  ","version":"Next","tagName":"h2"},{"title":"Install ApiGear CLI​","type":1,"pageTitle":"Installation","url":"/docs/start/install#install-apigear-cli","content":" ApiGear CLI is a command line tool to generate code from API modules. It is available for Mac, Windows and Linux. You can download the latest version from Github Releases Site.  The CLI provides all features of the Studio. ","version":"Next","tagName":"h2"},{"title":"First Steps","type":0,"sectionRef":"#","url":"/docs/start/first_steps","content":"","keywords":"","version":"Next"},{"title":"Using the Studio​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#using-the-studio","content":" When you run the Studio for the first time you need to accept our TOS once. This is a requirement to get the Studio working.  ","version":"Next","tagName":"h2"},{"title":"First Project​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#first-project","content":" APIs are collected inside a project. A project is a folder with an apigear folder inside. The folder contains the API description and other documents to help you with the project.  To create the first project you click New Project project overview. A dialog does open to select a folder for your new project. Ideally you create an empty folder before or you create one in this dialog. When you click OK the project will be created and an apigear folder will be created inside the selected folder.  Now you have an empty project without any APIs. You can add APIs to the project by clicking New -&gt; API Module documents overview. The dialog will open to name your new API. When clicking OK the API will be created and a new document will be shown n the overview.  The view has now changed to the Api Modules view. Here you see all your API modules and actions to manage them. To edit and API you can click the Edit icon. It will open the API editor, which is normally Visual Studio Code.  You can now edit and save the API Module. API modules structure and meaning is defined in the ObjectAPI Specification.  ","version":"Next","tagName":"h2"},{"title":"Install Code Templates​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#install-code-templates","content":" To create your first SDK from API modules we need to have Code Templates installed and a configuration file, called solution.  In the Templates view you see all templates available from the ApiGear cloud. You can install templates by clicking the Install button. The templates are installed in a local folder on you drive.  The name of a template will be used later for creating a SDK from the API modules.  ","version":"Next","tagName":"h2"},{"title":"Create a Solution​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#create-a-solution","content":" A solution binds API modules with an SDK. It can contain several layers of code generation. For example you can generate a C++ SDK from the API modules, as also a Python SDK. All templates have also different features for example http or olink support. Which features are supported is different for each template.  tip In the ObjectAPI Mapping is a description how different APIs are mapped to different transports and protocols.  A solution is a document and can be created using the New -&gt; Solution action. The dialog allows you to name the solution. When clicking OK the solution will be created and a new document will be shown. Also the view has changed to the &quot;Solution&quot; view.  To edit the solution click the Edit icon. The solution will be opened in the editor.  Now you can add our inputs to the solution. Inputs can be API modules in the form of the YAML of IDL format. As also the template we installed earlier.  layers: - name: &quot;C++&quot; inputs: - &lt;name&gt;.module.yaml output: &quot;../output&quot; template: &lt;template-name&gt;   Make sure you also have added an output folder where the SDK will be generated. The output folder is relative to the solution document.  A solution can have several layers and each layer can have many modules. This is how you can create even complex solutions with one run.  ","version":"Next","tagName":"h2"},{"title":"Code generation​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#code-generation","content":" The code generator is driven by the solution. It will generate the code based on the solution content. To run the solution we need to be in the &quot;Solution&quot; view and click Run next to one of the solutions.  A dialog will appear and you see the code generation progress. At the end a short summary will be printed.  You code is now generated in the output folder. In case you want to see the generated code you can open the output folder in your favorite file explorer.  tip In case an error appears the generation will be stopped and the error will be displayed. ","version":"Next","tagName":"h2"},{"title":"Typescript SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/typescript-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#interfaces","content":" An interface like this counter will be directly transformed to an TypeScript interface  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The interface will then later be used to be implemented by the customer. A reference implementation is created by the scaffold feature.  export interface ICounter { count: number increment(): void }   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a class with public fields.  export class Message { text: string; }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  export enum Direction { Up = 0, Down = 1, Left = 2, Right = 3, }  ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/docs/studio/project","content":"","keywords":"","version":"Next"},{"title":"Create project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#create-project","content":" To create a new project, click the New project button. It will open the Create project dialog. it shows a folder select dialog. Select the folder where you want to create the project. The project name will be the name of the selected folder. Inside the folder a new folder will be created with the name apigear. This folder will contain the project configuration and all documents.  ","version":"Next","tagName":"h2"},{"title":"Open project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#open-project","content":" To open an existing project, click the Open project button. It will open the Open project dialog. It shows a folder select dialog. Select the folder where the project is located. The project name will be the name of the selected folder. The project configuration and all documents will be loaded from the apigear folder inside the selected folder.  ","version":"Next","tagName":"h2"},{"title":"Import project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#import-project","content":" To import an existing project, click the Import project button. It will open the Import project dialog. It shows a folder select dialog. Select the folder where the project is located. The project name will be the name of the selected folder. The project configuration and all documents will be copied from the selected folder to the apigear folder inside the selected folder.  ","version":"Next","tagName":"h2"},{"title":"Recent projects​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#recent-projects","content":" To open a recent select one of the recent projects. It will open the project. ","version":"Next","tagName":"h2"},{"title":"Qt C++ SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/qtcpp-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class AbstractCounter : public QObject { Q_OBJECT public: AbstractCounter(QObject * parent=nullptr); virtual void setCount(int count) = 0; virtual int count() const = 0; virtual void increment() = 0; Q_SIGNALS: void countChanged(int count); };   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Qt C++ gadget so it can be also be used later in QML.  class Message { Q_GADGET Q_PROPERTY(QString text READ text WRITE setText) public: Message(); void setText(const QString&amp; text); QString text() const; bool operator==(const Message &amp;other) const; bool operator!=(const Message &amp;other) const; private: QString m_text; }; Q_DECLARE_METATYPE(Message)   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#enumerations","content":" A enumeration will be transformed to a standalone class with an enum embedded.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  class Direction : public QObject { Q_OBJECT public: Direction(QObject *parent = nullptr) : QObject(parent) {} enum DirectionEnum { Up = 0, Down = 1, Left = 2, Right = 3, }; Q_ENUM(DirectionEnum) static DirectionEnum toEnum(quint8 v, bool *ok); };  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/studio/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/docs/studio/intro#installation","content":" The desktop studio is available for Linux, MacOS and Windows. It can be installed from the release page.  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Introduction","url":"/docs/studio/intro#update","content":" The desktop studio will automatically check for updates and prompt you to update when a new version is available. The update will be downloaded in the background and installed when you restart the application.  The update is checked once per application start.  tip There are currently no certificates for the update server. This means that you will get a warning when you start the application for the first time.There is currently no support for manually check for updates. This feature will be added in the future. ","version":"Next","tagName":"h2"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/studio/quickstart","content":"","keywords":"","version":"Next"},{"title":"Project Selection​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#project-selection","content":" ","version":"Next","tagName":"h2"},{"title":"Documents​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#documents","content":" ","version":"Next","tagName":"h2"},{"title":"Code Generation​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#code-generation","content":" ","version":"Next","tagName":"h2"},{"title":"Monitoring​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#monitoring","content":" ","version":"Next","tagName":"h2"},{"title":"Simulation​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#simulation","content":"","version":"Next","tagName":"h2"}],"options":{"highlightResult":true,"id":"default"}}